var S=Symbol.for,O=Symbol("kCapture"),k=S("events.errorMonitor"),P=Symbol("events.maxEventTargetListeners"),R=Symbol("events.maxEventTargetListenersWarned"),I=S("nodejs.rejection"),L=S("nodejs.rejection"),C=Array.prototype.slice,w=10,H=function($){if(this._events===void 0||this._events===this.__proto__._events)this._events={__proto__:null},this._eventsCount=0;if(this._maxListeners??=void 0,this[O]=$?.captureRejections?Boolean($?.captureRejections):Q[O])this.emit=d},Q=H.prototype={};Q._events=void 0;Q._eventsCount=0;Q._maxListeners=void 0;Q.setMaxListeners=function($){return N($,"setMaxListeners",0),this._maxListeners=$,this};Q.constructor=H;Q.getMaxListeners=function(){return this?._maxListeners??w};function b(q,$){var{_events:z}=q;if($[0]??=Error("Unhandled error."),!z)throw $[0];var J=z[k];if(J)for(var K of C.call(J))K.apply(q,$);var X=z.error;if(!X)throw $[0];for(var K of C.call(X))K.apply(q,$);return!0}function f(q,$,z,J){$.then(void 0,function(K){queueMicrotask(()=>u(q,K,z,J))})}function u(q,$,z,J){if(typeof q[I]==="function")q[I]($,z,...J);else try{q[O]=!1,q.emit("error",$)}finally{q[O]=!0}}var h=function($,...z){if($==="error")return b(this,z);var{_events:J}=this;if(J===void 0)return!1;var K=J[$];if(K===void 0)return!1;let X=K.length>1?K.slice():K;for(let B=0,{length:U}=X;B<U;B++){let Z=X[B];switch(z.length){case 0:Z.call(this);break;case 1:Z.call(this,z[0]);break;case 2:Z.call(this,z[0],z[1]);break;case 3:Z.call(this,z[0],z[1],z[2]);break;default:Z.apply(this,z);break}}return!0},d=function($,...z){if($==="error")return b(this,z);var{_events:J}=this;if(J===void 0)return!1;var K=J[$];if(K===void 0)return!1;let X=K.length>1?K.slice():K;for(let B=0,{length:U}=X;B<U;B++){let Z=X[B],F;switch(z.length){case 0:F=Z.call(this);break;case 1:F=Z.call(this,z[0]);break;case 2:F=Z.call(this,z[0],z[1]);break;case 3:F=Z.call(this,z[0],z[1],z[2]);break;default:F=Z.apply(this,z);break}if(F!==void 0&&typeof F?.then==="function"&&F.then===Promise.prototype.then)f(this,F,$,z)}return!0};Q.emit=h;Q.addListener=function($,z){V(z);var J=this._events;if(!J)J=this._events={__proto__:null},this._eventsCount=0;else if(J.newListener)this.emit("newListener",$,z.listener??z);var K=J[$];if(!K)J[$]=[z],this._eventsCount++;else{K.push(z);var X=this._maxListeners??w;if(X>0&&K.length>X&&!K.warned)T(this,$,K)}return this};Q.on=Q.addListener;Q.prependListener=function($,z){V(z);var J=this._events;if(!J)J=this._events={__proto__:null},this._eventsCount=0;else if(J.newListener)this.emit("newListener",$,z.listener??z);var K=J[$];if(!K)J[$]=[z],this._eventsCount++;else{K.unshift(z);var X=this._maxListeners??w;if(X>0&&K.length>X&&!K.warned)T(this,$,K)}return this};function T(q,$,z){z.warned=!0;let J=Error(`Possible EventEmitter memory leak detected. ${z.length} ${String($)} listeners added to [${q.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);J.name="MaxListenersExceededWarning",J.emitter=q,J.type=$,J.count=z.length,console.warn(J)}function _(q,$,...z){this.removeListener(q,$),$.apply(this,z)}Q.once=function($,z){V(z);let J=_.bind(this,$,z);return J.listener=z,this.addListener($,J),this};Q.prependOnceListener=function($,z){V(z);let J=_.bind(this,$,z);return J.listener=z,this.prependListener($,J),this};Q.removeListener=function($,z){V(z);var{_events:J}=this;if(!J)return this;var K=J[$];if(!K)return this;var X=K.length;let B=-1;for(let U=X-1;U>=0;U--)if(K[U]===z||K[U].listener===z){B=U;break}if(B<0)return this;if(B===0)K.shift();else K.splice(B,1);if(K.length===0)delete J[$],this._eventsCount--;return this};Q.off=Q.removeListener;Q.removeAllListeners=function($){var{_events:z}=this;if($&&z){if(z[$])delete z[$],this._eventsCount--}else this._events={__proto__:null};return this};Q.listeners=function($){var{_events:z}=this;if(!z)return[];var J=z[$];if(!J)return[];return J.map((K)=>K.listener??K)};Q.rawListeners=function($){var{_events:z}=this;if(!z)return[];var J=z[$];if(!J)return[];return J.slice()};Q.listenerCount=function($){var{_events:z}=this;if(!z)return 0;return z[$]?.length??0};Q.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};Q[O]=!1;function E(q,$,z){var J=z?.signal;if(x(J,"options.signal"),J?.aborted)throw new j(void 0,{cause:J?.reason});let{resolve:K,reject:X,promise:B}=$newPromiseCapability(Promise),U=(W)=>{if(q.removeListener($,Z),J!=null)Y(J,"abort",F);X(W)},Z=(...W)=>{if(typeof q.removeListener==="function")q.removeListener("error",U);if(J!=null)Y(J,"abort",F);K(W)};if(M(q,$,Z,{once:!0}),$!=="error"&&typeof q.once==="function")q.once("error",U);function F(){Y(q,$,Z),Y(q,"error",U),X(new j(void 0,{cause:J?.reason}))}if(J!=null)M(J,"abort",F,{once:!0});return B}function y(q,$){return q.listeners($)}function v(q,...$){N(q,"setMaxListeners",0);var z;if($&&(z=$.length))for(let J=0;J<z;J++)$[J].setMaxListeners(q);else w=q}function p(q,$){return q.listenerCount($)}function Y(q,$,z,J){if(typeof q.removeListener==="function")q.removeListener($,z);else q.removeEventListener($,z,J)}function M(q,$,z,J){if(typeof q.on==="function")if(J.once)q.once($,z);else q.on($,z);else q.addEventListener($,z,J)}class j extends Error{constructor(q="The operation was aborted",$=void 0){if($!==void 0&&typeof $!=="object")throw D("options","Object",$);super(q,$);this.code="ABORT_ERR",this.name="AbortError"}}function D(q,$,z){let J=TypeError(`The "${q}" argument must be of type ${$}. Received ${z}`);return J.code="ERR_INVALID_ARG_TYPE",J}function g(q,$,z){let J=RangeError(`The "${q}" argument is out of range. It must be ${$}. Received ${z}`);return J.code="ERR_OUT_OF_RANGE",J}function x(q,$){if(q!==void 0&&(q===null||typeof q!=="object"||!("aborted"in q)))throw D($,"AbortSignal",q)}function N(q,$,z,J){if(typeof q!=="number")throw D($,"number",q);if(z!=null&&q<z||J!=null&&q>J||(z!=null||J!=null)&&Number.isNaN(q))throw g($,`${z!=null?`>= ${z}`:""}${z!=null&&J!=null?" && ":""}${J!=null?`<= ${J}`:""}`,q)}function V(q){if(typeof q!=="function")throw TypeError("The listener must be a function")}function o(q,$){if(typeof q!=="boolean")throw D($,"boolean",q)}function m(q){return q?._maxListeners??w}function l(q,$){if(q===void 0)throw D("signal","AbortSignal",q);if(x(q,"signal"),typeof $!=="function")throw D("listener","function",$);let z;if(q.aborted)queueMicrotask(()=>$());else q.addEventListener("abort",$,{__proto__:null,once:!0}),z=()=>{q.removeEventListener("abort",$)};return{__proto__:null,[Symbol.dispose](){z?.()}}}Object.defineProperties(H,{captureRejections:{get(){return Q[O]},set(q){o(q,"EventEmitter.captureRejections"),Q[O]=q},enumerable:!0},defaultMaxListeners:{enumerable:!0,get:()=>{return w},set:(q)=>{N(q,"defaultMaxListeners",0),w=q}},kMaxEventTargetListeners:{value:P,enumerable:!1,configurable:!1,writable:!1},kMaxEventTargetListenersWarned:{value:R,enumerable:!1,configurable:!1,writable:!1}});Object.assign(H,{once:E,getEventListeners:y,getMaxListeners:m,setMaxListeners:v,EventEmitter:H,usingDomains:!1,captureRejectionSymbol:L,errorMonitor:k,addAbortListener:l,init:H,listenerCount:p});var G=new H;function A(q,$){G.on(`@aaperta/pager:page:${q}`,$)}function c(q){G.emit(`@aperta/pager:page:${q}`)}var z$={listen:A,page:c};export{z$ as pager};
