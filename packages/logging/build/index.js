var N=Symbol.for,D=Symbol("kCapture"),b=N("events.errorMonitor"),u=Symbol("events.maxEventTargetListeners"),h=Symbol("events.maxEventTargetListenersWarned"),k=N("nodejs.rejection"),d=N("nodejs.rejection"),C=Array.prototype.slice,H=10,F=function($){if(this._events===void 0||this._events===this.__proto__._events)this._events={__proto__:null},this._eventsCount=0;if(this._maxListeners??=void 0,this[D]=$?.captureRejections?Boolean($?.captureRejections):K[D])this.emit=p},K=F.prototype={};K._events=void 0;K._eventsCount=0;K._maxListeners=void 0;K.setMaxListeners=function($){return j($,"setMaxListeners",0),this._maxListeners=$,this};K.constructor=F;K.getMaxListeners=function(){return this?._maxListeners??H};function c(q,$){var{_events:z}=q;if($[0]??=Error("Unhandled error."),!z)throw $[0];var B=z[b];if(B)for(var J of C.call(B))J.apply(q,$);var Q=z.error;if(!Q)throw $[0];for(var J of C.call(Q))J.apply(q,$);return!0}function o(q,$,z,B){$.then(void 0,function(J){queueMicrotask(()=>E(q,J,z,B))})}function E(q,$,z,B){if(typeof q[k]==="function")q[k]($,z,...B);else try{q[D]=!1,q.emit("error",$)}finally{q[D]=!0}}var g=function($,...z){if($==="error")return c(this,z);var{_events:B}=this;if(B===void 0)return!1;var J=B[$];if(J===void 0)return!1;let Q=J.length>1?J.slice():J;for(let X=0,{length:Z}=Q;X<Z;X++){let S=Q[X];switch(z.length){case 0:S.call(this);break;case 1:S.call(this,z[0]);break;case 2:S.call(this,z[0],z[1]);break;case 3:S.call(this,z[0],z[1],z[2]);break;default:S.apply(this,z);break}}return!0},p=function($,...z){if($==="error")return c(this,z);var{_events:B}=this;if(B===void 0)return!1;var J=B[$];if(J===void 0)return!1;let Q=J.length>1?J.slice():J;for(let X=0,{length:Z}=Q;X<Z;X++){let S=Q[X],U;switch(z.length){case 0:U=S.call(this);break;case 1:U=S.call(this,z[0]);break;case 2:U=S.call(this,z[0],z[1]);break;case 3:U=S.call(this,z[0],z[1],z[2]);break;default:U=S.apply(this,z);break}if(U!==void 0&&typeof U?.then==="function"&&U.then===Promise.prototype.then)o(this,U,$,z)}return!0};K.emit=g;K.addListener=function($,z){Y(z);var B=this._events;if(!B)B=this._events={__proto__:null},this._eventsCount=0;else if(B.newListener)this.emit("newListener",$,z.listener??z);var J=B[$];if(!J)B[$]=[z],this._eventsCount++;else{J.push(z);var Q=this._maxListeners??H;if(Q>0&&J.length>Q&&!J.warned)x(this,$,J)}return this};K.on=K.addListener;K.prependListener=function($,z){Y(z);var B=this._events;if(!B)B=this._events={__proto__:null},this._eventsCount=0;else if(B.newListener)this.emit("newListener",$,z.listener??z);var J=B[$];if(!J)B[$]=[z],this._eventsCount++;else{J.unshift(z);var Q=this._maxListeners??H;if(Q>0&&J.length>Q&&!J.warned)x(this,$,J)}return this};function x(q,$,z){z.warned=!0;let B=Error(`Possible EventEmitter memory leak detected. ${z.length} ${String($)} listeners added to [${q.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);B.name="MaxListenersExceededWarning",B.emitter=q,B.type=$,B.count=z.length,console.warn(B)}function T(q,$,...z){this.removeListener(q,$),$.apply(this,z)}K.once=function($,z){Y(z);let B=T.bind(this,$,z);return B.listener=z,this.addListener($,B),this};K.prependOnceListener=function($,z){Y(z);let B=T.bind(this,$,z);return B.listener=z,this.prependListener($,B),this};K.removeListener=function($,z){Y(z);var{_events:B}=this;if(!B)return this;var J=B[$];if(!J)return this;var Q=J.length;let X=-1;for(let Z=Q-1;Z>=0;Z--)if(J[Z]===z||J[Z].listener===z){X=Z;break}if(X<0)return this;if(X===0)J.shift();else J.splice(X,1);if(J.length===0)delete B[$],this._eventsCount--;return this};K.off=K.removeListener;K.removeAllListeners=function($){var{_events:z}=this;if($&&z){if(z[$])delete z[$],this._eventsCount--}else this._events={__proto__:null};return this};K.listeners=function($){var{_events:z}=this;if(!z)return[];var B=z[$];if(!B)return[];return B.map((J)=>J.listener??J)};K.rawListeners=function($){var{_events:z}=this;if(!z)return[];var B=z[$];if(!B)return[];return B.slice()};K.listenerCount=function($){var{_events:z}=this;if(!z)return 0;return z[$]?.length??0};K.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};K[D]=!1;function y(q,$,z){var B=z?.signal;if(_(B,"options.signal"),B?.aborted)throw new W(void 0,{cause:B?.reason});let{resolve:J,reject:Q,promise:X}=$newPromiseCapability(Promise),Z=(V)=>{if(q.removeListener($,S),B!=null)G(B,"abort",U);Q(V)},S=(...V)=>{if(typeof q.removeListener==="function")q.removeListener("error",Z);if(B!=null)G(B,"abort",U);J(V)};if(M(q,$,S,{once:!0}),$!=="error"&&typeof q.once==="function")q.once("error",Z);function U(){G(q,$,S),G(q,"error",Z),Q(new W(void 0,{cause:B?.reason}))}if(B!=null)M(B,"abort",U,{once:!0});return X}function v(q,$){return q.listeners($)}function m(q,...$){j(q,"setMaxListeners",0);var z;if($&&(z=$.length))for(let B=0;B<z;B++)$[B].setMaxListeners(q);else H=q}function l(q,$){return q.listenerCount($)}function G(q,$,z,B){if(typeof q.removeListener==="function")q.removeListener($,z);else q.removeEventListener($,z,B)}function M(q,$,z,B){if(typeof q.on==="function")if(B.once)q.once($,z);else q.on($,z);else q.addEventListener($,z,B)}class W extends Error{constructor(q="The operation was aborted",$=void 0){if($!==void 0&&typeof $!=="object")throw O("options","Object",$);super(q,$);this.code="ABORT_ERR",this.name="AbortError"}}function O(q,$,z){let B=TypeError(`The "${q}" argument must be of type ${$}. Received ${z}`);return B.code="ERR_INVALID_ARG_TYPE",B}function i(q,$,z){let B=RangeError(`The "${q}" argument is out of range. It must be ${$}. Received ${z}`);return B.code="ERR_OUT_OF_RANGE",B}function _(q,$){if(q!==void 0&&(q===null||typeof q!=="object"||!("aborted"in q)))throw O($,"AbortSignal",q)}function j(q,$,z,B){if(typeof q!=="number")throw O($,"number",q);if(z!=null&&q<z||B!=null&&q>B||(z!=null||B!=null)&&Number.isNaN(q))throw i($,`${z!=null?`>= ${z}`:""}${z!=null&&B!=null?" && ":""}${B!=null?`<= ${B}`:""}`,q)}function Y(q){if(typeof q!=="function")throw TypeError("The listener must be a function")}function s(q,$){if(typeof q!=="boolean")throw O($,"boolean",q)}function a(q){return q?._maxListeners??H}function n(q,$){if(q===void 0)throw O("signal","AbortSignal",q);if(_(q,"signal"),typeof $!=="function")throw O("listener","function",$);let z;if(q.aborted)queueMicrotask(()=>$());else q.addEventListener("abort",$,{__proto__:null,once:!0}),z=()=>{q.removeEventListener("abort",$)};return{__proto__:null,[Symbol.dispose](){z?.()}}}Object.defineProperties(F,{captureRejections:{get(){return K[D]},set(q){s(q,"EventEmitter.captureRejections"),K[D]=q},enumerable:!0},defaultMaxListeners:{enumerable:!0,get:()=>{return H},set:(q)=>{j(q,"defaultMaxListeners",0),H=q}},kMaxEventTargetListeners:{value:u,enumerable:!1,configurable:!1,writable:!1},kMaxEventTargetListenersWarned:{value:h,enumerable:!1,configurable:!1,writable:!1}});Object.assign(F,{once:y,getEventListeners:v,getMaxListeners:a,setMaxListeners:m,EventEmitter:F,usingDomains:!1,captureRejectionSymbol:d,errorMonitor:b,addAbortListener:n,init:F,listenerCount:l});var I=new F;var A=[];function w(q,$,z){let B=new Date,J=B.getFullYear(),Q=(B.getMonth()+1).toString().padStart(2,"0"),X=B.getDate().toString().padStart(2,"0"),Z=B.getHours().toString().padStart(2,"0"),S=B.getMinutes().toString().padStart(2,"0"),U=`${J}-${Q}-${X} ${Z}:${S}`;if(console.log(`${U} [${q}] [${$}] ${z}`),$ in A)I.emit(`@aperta/logging:sink:${$}`,{pid:process.pid,date:B,message:z,level:q})}function R(q,$){w("DEBUG",q,$)}function f(q,$){w("ERROR",q,$)}function P(q,$){w("INFO",q,$)}function L(q,$){w("WARN",q,$)}var G$={info:P,error:f,warn:L,debug:R};export{G$ as logger};
